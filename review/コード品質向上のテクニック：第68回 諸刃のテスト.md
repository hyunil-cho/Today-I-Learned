【DroidKaigi 2023】[Code Review Challenge 5問目解説](https://techblog.lycorp.co.jp/ja/20250424icq)

# Review Committee

매주 목요일 사내에서 코드 퀄리티를 유지, 높이기 위한 활동을 매주 진행중이며, 이 중, 일부는 공식 블록스에 게재되고 있다.

# 諸刃のテスト

```
class FooModel(val title: String, val description: String)

class FooModelLogger(
    private val textLogger: TextLogger = TextLogger(),
    private val joinString: String.(Any?) -> String = String::plus,
    private val decorate: (String) -> String = { text -> LogTextUtility.decorateText(text, "*") },
    private val getTitle: FooModel.() -> String = { this.title },
) {
    fun log(model: FooModel) {
        val titleToLog = model.getTitle()
        val decoratedTitle = decorate(titleToLog)
        val combinedOutput = decoratedTitle.joinString(model.description)
        textLogger.log(combinedOutput)
    }
}

object LogTextUtility {
    fun decorateText(text: String, decoration: String): String = ...
}
```

```
@Test
    fun `logs title and description with a normal FooModelObject`() {
        val mockTextLogger: TextLogger = mock()
        val mockJoinString: String.(Any?) -> String = { _ -> this + "MockDescription" }
        val mockDecorate: (String) -> String = { "@$it@" }
        val mockGetTitle: FooModel.() -> String = { "MockTitle" }

        val subject = FooModelLogger(
            textLogger = mockTextLogger,
            joinString = mockJoinString,
            decorate = mockDecorate,
            getTitle = mockGetTitle
        )

        val fooModel = FooModel("RealTitle", "RealDescription")
        subject.log(fooModel)

        verify(mockTextLogger).log("@MockTitle@MockDescription")
    }
```

## 위 코드의 문제점

1. 테스트가 복잡하다. 테스트를 하기 위해서는 많은 mock,  stub이 필요하다. 또한, 테스트 대상이 변경되면, 그만큼 테스트코드도 변경되어야 한다.
2. 統合テストの不足 -> 많은 mock이 사용되기 때문에, 실제 의존하는 코드(목으로 대체된)와 제대로 연동이 되는지 확인하기가 어려움

## 그렇다면 무엇을 해야 하는가?

외부에서 주입하는 코드를 촤소화한다. 이 예의 경우, Logger(실제 로그를 OS에 저장하는) 코드만 mock으로 주입하면 충분. 이렇게 하면, 실제 동작하는 코드와 테스트하는 코드가 거의 동일하기 때문에, 테스트 결과를 더 신뢰할 수 있음.

```
class FooModelLogger(private val textLogger: TextLogger = TextLogger()) {
    fun log(model: FooModel) {
        val decoratedTitle = LogTextUtility.decorateText(model.title, "*")
        val combinedOutput = decoratedTitle + model.description
        textLogger.log(combinedOutput)
    }
}
```

이에 대하여, 그렇다면 언제 로직을 외부에 위임해야 할지에 대한 고민이 필요할 것이며, 이에 대한 나의 생각은 다음과 같음

1. 변할 수 있는 것. 예를 들어, 빈번하게 요구사항이 변경될 수 있는 부분이라면, 이는 외부에서 주입 받는 것이 더 유리함.
2. 외부 시스템과 통신하는 부분 - 이에 대하여 따로 처리하는 것이 아니라, 단순히 데이터를 전송하거나, 적절한 프로토콜로 변환하여 전송하는 등, 단순 IO 작업이 필요한 로직의 경우에는 위임해서 처리하는 것이 좋을 듯
3. 멱등적이지 않은 API 호

## 주의점

반드시 mock을 쓰지 말자는 것은 아님. 그저 사용해야 한다면, <諸刃はシャープに使う!>

## 추천하는 상황

実行環境や外部環境に依存する場合 (例: Locale 固有のロジック, Network API Client)
再現性を保証できない場合 (例: 乱数, 現在時刻)
実行に時間がかかる、またはリソースを多く消費する場合
インスタンス化やセットアップ、リセットに複雑な手順が必要な場合
状態遷移やロジックが複雑で、単純なテストでは扱いにくい場合
依存先のコードが多くのレイヤーやモジュールにまたがり、テストが広範囲になりすぎる場合
依存先のコードの仕様が固まっているが、まだ実装中で完成していない場合

